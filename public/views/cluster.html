<!DOCTYPE html>
<html lang="en">

<head data-dir="{{dir}}" data-user="{{user}}" data-login="{{login}}">

  <title>GEOLYTIX Skunkworks</title>

  <link rel="icon" type="image/x-icon" href="{{dir}}/icons/favicon.ico" />

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="{{dir}}/css/mapp.css" />

  <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.9.0/build/ol.js" defer></script>

  <script type="module" src="{{dir}}/js/lib/mapp.js" defer></script>
    
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: Arial, Helvetica, sans-serif;
    }

    #Map {
      width: 100%;
      height: 100%;
    }

  </style>

</head>

<body>

  <div id="Map"></div>

</body>

<script>

  window.onload = async () => {

    const host = document.head.dataset.dir || new String("");

    const locale = await mapp.utils.xhr(`${host}/api/workspace/locale?locale=Bristol`);

    const mapview = mapp.Mapview({
      host: host,
      target: 'Map',
      locale: locale,
      scrollWheelZoom: true,
      controls: [new ol.control.Zoom()],
      attribution: {
        target: document.querySelector('#Map > .attribution-links'),
        links: {
          [`XYZ v${mapp.version}`]: "https://geolytix.github.io/xyz",
          ["SHA"]: `https://github.com/GEOLYTIX/xyz/commit/${mapp.hash}`,
          Openlayers: "https://openlayers.org",
        },
      }
    });

    const layers = await mapp.utils.promiseAll(locale.layers.map(
      layer => mapp.utils.xhr(`${host}/api/workspace/layer?`
        + `locale=${locale.key}&layer=${layer}`)))

    sentiment_layer = layers.find(layer => layer.key === 'sentiment')

    //sentiment_layer.styleFunction = styleFunction

    sentiment_layer.style.default.icon = singleStyle

    sentiment_layer.style.cluster.icon = clusterStyle

    const sourceLocations = new ol.source.Vector()

    const layerLocations = new ol.layer.Vector({
      source: sourceLocations
    })

    sentiment_layer.hover = F => {

      sourceLocations.clear()

      let features = F.get('features')
      
      if (features.length > 1) {
        features.forEach(f => sourceLocations.addFeature(f.clone()))
      }
    }
    
    await mapview.addLayer(layers);

    mapview.Map.addLayer(layerLocations)

    const xmlSerializer = new XMLSerializer();

    const sentimentColour = {
      0: '#00ac5d',
      25: '#89c92d',
      50: '#feb000',
      75: '#ff7700',
      100: '#e80030'
    }

    const memoizedStyles = {};

    function singleStyle(feature) {

      let highlight = feature.get('highlight')

      let features = feature.get('features')

      let colour = sentimentColour[features[0].getProperties().properties.sentiment]

      if (!highlight && memoizedStyles[colour]) {
        return memoizedStyles[colour]
      }

      let icon = mapp.utils.svg.node`
        <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
          <circle cx=12 cy=12 r=12 fill=${colour}></circle>`;

      let style = new ol.style.Style({
        image: new ol.style.Icon({
          src: `data:image/svg+xml,${encodeURIComponent(
            xmlSerializer.serializeToString(icon)
          )}`,
          scale: highlight && 2 || 1,
          //scale: 1,
          anchor: [0.5, 0.5]
        })
      })

      if (highlight) return style

      memoizedStyles[colour] = style

      return style
    }

    function clusterStyle(feature) {

      let highlight = feature.get('highlight')

      let features = feature.get('features')

      let clusterSentiment = {
        0: 0,
        25: 0,
        50: 0,
        75: 0,
        100: 0
      }

      for (let i = 0; i < features.length - 1; i++) {
        clusterSentiment[features[i].getProperties().properties.sentiment]++
      }

      let clusterSentimentString = JSON.stringify(clusterSentiment)

      if (!highlight && memoizedStyles[clusterSentimentString]) {
        return memoizedStyles[clusterSentimentString]
      }

      let start = 0

      let icon = mapp.utils.svg.node`
        <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
          <circle cx=12 cy=12 r=12 fill='#555'></circle>`;

      Object.entries(clusterSentiment).map(sentVal => {

        if (sentVal[1]) {

          segment = (sentVal[1] / (features.length - 1)) * 100
         
          icon.appendChild(mapp.utils.svg.node`
            <path
              d=${createSvgArc([12, 12], 12, [start, segment-0.01])}
              fill=${sentimentColour[sentVal[0]]}/>`)

          start= start + segment
        }

      })

      icon.appendChild(mapp.utils.svg.node`
        <circle cx=12 cy=12 r=8 fill='#fff'></circle>`)

      let style = new ol.style.Style({
        image: new ol.style.Icon({
          src: `data:image/svg+xml,${encodeURIComponent(
            xmlSerializer.serializeToString(icon)
          )}`,
          scale: highlight && 3 || 2,
          //scale: 2,
          anchor: [0.5, 0.5]
        }),
        text: new ol.style.Text({
          font: '16px sans-serif',
          text: String(features.length),
          fill: new ol.style.Fill({
            color: '#000'
          })
        })
      })

      if (highlight) return style

      memoizedStyles[clusterSentimentString] = style

      return style

    }

    function styleFunction(feature) {

      let features = feature.get('features')

      return features.length === 1 ?
        singleStyle(feature) :
        clusterStyle(feature);
    }


    //let featureHighlight;

    mapview.interactions.highlight({
      layerFilter: featureLayer => mapview.layers.sentiment.L === featureLayer,
      // highlight: f => {

      //   if (f === 'noChange') return;

      //   if (!f) {
      //     featureHighlight && featureHighlight.set('highlight', false)
      //     featureHighlight && featureHighlight.setStyle(styleFunction(featureHighlight))
      //     featureHighlight = null;
      //     return;
      //   }

      //   if (featureHighlight === f.F) return;

      //   sourceLocations.clear()

      //   let features = f.F.get('features')

      //   features?.length > 1 && features.forEach(loc => sourceLocations.addFeature(loc.clone()))

      //   featureHighlight && featureHighlight.set('highlight', false)

      //   featureHighlight && featureHighlight.setStyle(styleFunction(featureHighlight))

      //   featureHighlight = f.F

      //   featureHighlight.set('highlight', true)

      //   featureHighlight.setStyle(styleFunction(featureHighlight))
      // }
    });

  }

  function createSvgArc([cx,cy],r,[start,sweep],φ = -1.5708){

    let t1 = start * 0.062831853071796;

    let Δ = sweep * 0.062831853071796;

    /*
      cx,cy → center of ellipse
      r → radius
      t1 → start angle, in radian.
      Δ → angle to sweep, in radian. positive.
      φ → rotation on the whole, in radian
      URL: SVG Circle Arc http://xahlee.info/js/svg_circle_arc.html
    */

    const cos = Math.cos;
    const sin = Math.sin;
    const π = Math.PI;

    const f_matrix_times = (( [[a,b], [c,d]], [x,y]) => [ a * x + b * y, c * x + d * y]);
    const f_rotate_matrix = (x => [[cos(x),-sin(x)], [sin(x), cos(x)]]);
    const f_vec_add = (([a1, a2], [b1, b2]) => [a1 + b1, a2 + b2]);

    Δ = Δ % (2*π);
    const rotMatrix = f_rotate_matrix (φ);
    const [sX, sY] = ( f_vec_add ( f_matrix_times ( rotMatrix, [r * cos(t1), r * sin(t1)] ), [cx,cy] ) );
    const [eX, eY] = ( f_vec_add ( f_matrix_times ( rotMatrix, [r * cos(t1+Δ), r * sin(t1+Δ)] ), [cx,cy] ) );
    const fA = ( (  Δ > π ) ? 1 : 0 );
    const fS = ( (  Δ > 0 ) ? 1 : 0 );

    return ['M', cx, cy, 'L', sX, sY, 'A', r , r , φ / (2*π) *360, fA, fS, eX, eY, 'L', cx, cy].join(" ")
  }

</script>

</html>